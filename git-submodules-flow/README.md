# Джедайский манускрипт по submodul'ям (субмодулям, сабмодулям)

## Библия джедая

- Подумай 200 раз, а нужны ли тебе сабмодули, не проще ли просто разнести проект на 2 разных репо
- Если ты понял что нужны, подумай ещё 200 раз. Скорее всего, почти всегда можно обойтись без них
- работа с сабмодулями происходит только для инициализированных репо
- перед работой с сабмодулем инициализируй его через `git submodule update --init`
- после работы с сабмодулем деинициализируй его через `git submodule deinit`
- !!!!! в `.gitmodules` ни у одного сабмодуля не должно быть фиксации ветки !!!!!
- текущий комит сабмодуля является комитом на который ссылается мейн-репо
- по дефолту сабмодуль указывает на коммит, а не на ветку
- мейн-репо можт быть сабмодулем для другого мейн-репо
- Для каждой ветки мейн-репо существует ветка проекта в сабмодуле с соответствующим названием (master - master, dev - dev, SCRUM-1488 - SCRUM-1488)
- Если сабмодуль состоит в нескольких мейн-репо, в названиях веток этих мейн-репо не должно быть коллизий

## Воркфлоу

- ещё см. `Команды джедайского воркфлоу` и `Команды гитовые`
- для остальных ситуаций как обычно

### Если требуется создать фичу

- `gsf ch` на dev
- `gsf ch -b *brunch-name*` на новую ветку
- разработка фичи
- `gsf ch` на dev
- `gsf m *brunch-name*` в dev

### Если сабмодуль оказался где-то не там
- либо в ветке сабмодуля `git checkout *текущая ветка*`
- либо `gsf ch *ветка*`

## Команды джедайского воркфлоу

#### (gsf a) gsf add *params*

- Рекурсивно выполняет сначала для всех сабмодулей, затем для мейн репо `git add *params*`

#### (gsf ch) gsf checkout *params*

- Рекурсивно выполняет сначала для всех сабмодулей, затем для мейн репо `git checkout *params*`

#### (gsf chp) gsf checkout-pull -b *branch* *params*

- 1. Если `branch` не указан и текущая ветка в текущем мейн репо отсутствует, завершаем команду
- 2. Рекурсивно выполняет сначала для всех сабмодулей, затем для мейн репо: checkout на нужную ветку, затем pull
- TODO: коммитить указатели на сабмодули, если они меняются

#### (gsf c) gsf сommit *params*

- Рекурсивно выполняет сначала для всех сабмодулей, затем для мейн репо `git сommit *params*`
- TODO: научиться коммитить мейн репо если есть незакомиченые изменения в сабмодулях

#### (gsf m) gsf merge *branch-name* *params*

- Рекурсивно выполняет сначала для всех сабмодулей, затем для мейн репо `git merge *branch-name* *params*`
- TODO: коммитить указатели на сабмодули, если они меняются

#### (gsf p) gsf push *params*

- Рекурсивно выполняет сначала для всех сабмодулей, затем для мейн репо `git push *params*`

#### (gsf r) gsf reset *params*

- Рекурсивно выполняет сначала для всех сабмодулей, затем для мейн репо `git reset *params*`

#### (gsf s) gsf status *params*

- Рекурсивно выполняет сначала для всех сабмодулей, затем для мейн репо `git status *params*`

## Команды гитовые

- см. https://git-scm.com/docs/git-submodule

#### git clone --recurse-submodules *url to repo*

- выкачать репо вместе со всеми его сабмодулями
- по дефолту выкачивается только код родительского репо

#### git submodule add *url to repo*

- добавить в проект новый сабмодуль
- выполнять нужно в папке в которую добавится сабмодуль
- добавляет запись о новом сабмодуле в `.gitmodules`, добавляет запись, и выкачивает файлы

#### git submodule update --init *path to submodule*

- для уже добавленного сабмодуля выкачать его код с его текущей ветки
- предназначена для сабмодуля, вызывается из папки родительского репо
- работает для всех сабмодулей, если не указывать путь
- не вносит никаких изменений ни в родительский репо ни в сабмодуль, просто выкачивает код с гитхаба

#### git submodule deinit *path to submodule*

- деинициализирует сабмодуль, очищает папку в которой он лежит
- предназначена для сабмодуля, вызывается из папки родительского репо
- в родительском репо ничего не меняется

#### git submodule status

- показывает коммиты и ветки на которые ссылаются сабмодули в текущем коммите мейн-репо
- выполняется в основном репо

## Выпиливание сабмодуля в тартарары

- Заимствовано у джедаев англоговорящих планет (со стековерфлоу)
- Delete the relevant section from the .gitmodules file.
- Stage the .gitmodules changes git add .gitmodules
- Delete the relevant section from .git/config.
- Run git rm --cached path_to_submodule (no trailing slash).
- Run rm -rf .git/modules/path_to_submodule (no trailing slash).
- Commit git commit -m "Removed submodule "
- Delete the now untracked submodule files rm -rf path_to_submodule
